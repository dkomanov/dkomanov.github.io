{"componentChunkName":"component---src-templates-blog-post-js","path":"/p/base64-encoding-performance-java-vs-rust/","result":{"data":{"markdownRemark":{"id":"759b25f1-7c61-55ea-a66a-f1d59fe01e88","excerpt":"UPD: A lot of interesting comments on reddit: Added benchmarks for data-encoding crate. Added an optimized version of JDK ported implementation that brings Rust…","html":"<p>UPD: A lot of interesting comments on <a href=\"https://www.reddit.com/r/rust/comments/y5c91j/base64_encoding_performance_java_vs_rust/\">reddit</a>:</p>\n<ul>\n<li><a href=\"https://github.com/dkomanov/rust-stuff/commit/50b7cfd686ca3d23fcf4ee78483e5d6dafe35a57\">Added</a> benchmarks for <a href=\"https://docs.rs/data-encoding/latest/data_encoding/\">data-encoding</a> crate.</li>\n<li><a href=\"https://github.com/dkomanov/rust-stuff/commit/c222a95fae0812303c931d36d09b5acc7d1a95d8\">Added</a> an <a href=\"https://gist.github.com/Measter/e3d12d78777c9e1b125f0466c6b94498\">optimized</a> <a href=\"https://godbolt.org/z/5jEeq9713\">version</a> of JDK ported implementation that brings Rust closer to JVM for encoding.</li>\n<li>WOW. Merged <a href=\"https://github.com/dkomanov/rust-stuff/pull/1\">PR</a> using <a href=\"https://github.com/Nugine/simd\">base64-simd</a> crate, which performance is almost 10x better than anything else!</li>\n<li>Blog post remains the same, if you curious about new numbers: check it <a href=\"https://github.com/dkomanov/rust-stuff/blob/master/base64_manual_bench/src/main.rs#L9\">here</a> and <a href=\"https://komanov.com/data/charts/base64-rust/\">here</a>.</li>\n</ul>\n<p>I got curious… Not that’s something new to me. But a bit unusual thought after benchmarking <a href=\"/p/base64-encoding-performance-jdk-vs-apache-commons\">Base64</a> performance in Java: what is the maximum performance in unmanaged world? And since I wanted to explore <a href=\"https://www.rust-lang.org/\">Rust</a> a bit, I decided that it’s a good opportunity!</p>\n<p>I went to google to find something about benchmarking base64 encoding performance for Rust and stumbled upon a github <a href=\"https://github.com/marshallpierce/rust-base64/issues/159\">issue</a> saying that crate <a href=\"https://crates.io/crates/base64\">base64</a> isn’t that fast. That opened an opportunity for me to check it.</p>\n<h2 id=\"what-are-we-benchmarking\" style=\"position:relative;\"><a href=\"#what-are-we-benchmarking\" aria-label=\"what are we benchmarking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What Are We Benchmarking?</h2>\n<ul>\n<li><a href=\"https://crates.io/crates/base64\">base64</a> crate.</li>\n<li>Base64 encoding/decoding from <a href=\"https://crates.io/crates/crypto2\">crypto2</a> crate. Sadly, it’s not published so I had to copy-paste its code for benchmarking.</li>\n<li><a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Base64.html\">java.util.Base64</a>: I <a href=\"https://github.com/dkomanov/rust-stuff/tree/9daaadd43fc76b821614a318e3169eb3d2303371/base64_jdk/src\">ported</a> implementation from Java to Rust for benchmarking purposes.</li>\n</ul>\n<p>And then I want to compare it with the results of JVM benchmarks on the same inputs.</p>\n<p>For benchmarking Rust I used <a href=\"https://github.com/bheisler/criterion.rs\">criterion.rs</a>, a very nice tool for benchmarking. It does much more out of the box than <a href=\"https://github.com/openjdk/jmh\">JMH</a>. The hardware configuration is Intel® Core™ i7-1165G7 @ 2.80GHz × 8 (4 core + 4 HT) with 16 GB RAM.</p>\n<h2 id=\"benchmarks\" style=\"position:relative;\"><a href=\"#benchmarks\" aria-label=\"benchmarks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Benchmarks</h2>\n<p>Here are couple of graphs for Rust only, generated by Criterion: for encode and decode performance. <code class=\"language-text\">base64</code> implementation is a clear winner here for both encoding and decoding.</p>\n<p>Performance of <a href=\"/data/charts/base64-rust/encode/index.html\">encoding</a> for different input data sizes.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2c41d507d128738a77b50770a0c543ac/9831c/encode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.67567567567567%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQoz4WS627DIAyF+/5vOWm/tqZZIBibS850aJy16toiWRgbf5gDJ1WFmaGU8q/lnBFCAPd5zEpB9bwpTBUxC76nM04saK1h27anxsG5b/1Y19ZwkRXBFK1WaClQsyuw934UvQMTGjTjkhO01hFjp8448SrvgHsSa1FMsiIVA/awA3nLAYwxvgYByLUMEDu7jbt/B5zn+RHkG6lTTvhRQdtvwdbo82Ek56FbrfUP6Bre6dQ7FhXMWVD6dSMLWEwIjT/DIXcdUkNfsDPqM0kaM09mYRJB5vdy8W9e/gFoasPR1nCWFZe0jk50B1Q/7MXgwccrx5Tw8f2Fz+mMEOP4pHajixvXz8z/8lVDM8wxHCDbu3NLKWFZFojIkSPA8+7z2gT+Age3YavKspDrAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Encode\"\n        title=\"Encode\"\n        src=\"/static/2c41d507d128738a77b50770a0c543ac/50383/encode.png\"\n        srcset=\"/static/2c41d507d128738a77b50770a0c543ac/1d79a/encode.png 185w,\n/static/2c41d507d128738a77b50770a0c543ac/1efb2/encode.png 370w,\n/static/2c41d507d128738a77b50770a0c543ac/50383/encode.png 740w,\n/static/2c41d507d128738a77b50770a0c543ac/73caa/encode.png 1110w,\n/static/2c41d507d128738a77b50770a0c543ac/536c7/encode.png 1480w,\n/static/2c41d507d128738a77b50770a0c543ac/9831c/encode.png 1995w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Performance of <a href=\"/data/charts/base64-rust/decode/index.html\">decoding</a> for different input data sizes.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fb1ba561585d7f99cc26ec7677f3c897/540ab/decode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.21621621621622%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTUlEQVQoz32T626DMAyFef+nnLQ/3RDdIOBLHOdMTgkt3TpLVgyYz8dOMqgqRAQ55z+diJBSOuVozrA9TswgZlzTgnEcMUSimSGs1vrLux3Pu+dSsAW0FGhWLLK24kMoLKW8BD7DvVaQGdisxWGhFHvcgP8p7KBYAxKqzP2UH0D3Wzwsy/JSYbfenra8e4E9bMCeP0zTBH+q2D8W9wYKZUeBesvz6lBXSJU2wwPIzCgPLT+3V7yDKqzaAQk3ZBSUs8LHGd52z0HZWptNZfxWFeQEdkauGZwFiQkbMxIRROUM7LNgK1hNoDVUMOacsOQVqxKSEGbaMG9rg5EKViGo5bNCVsb7/IG3+YLLOmKiL0z0jZlXkDBYBKzaDnNsXnTjpaC6t9nHGmO7KzTF53bFN82Y09KShLhVjduwbRuYqK0Bi5/7rYl3USQOdN/YH/CTYYI4DvIpAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Decode\"\n        title=\"Decode\"\n        src=\"/static/fb1ba561585d7f99cc26ec7677f3c897/50383/decode.png\"\n        srcset=\"/static/fb1ba561585d7f99cc26ec7677f3c897/1d79a/decode.png 185w,\n/static/fb1ba561585d7f99cc26ec7677f3c897/1efb2/decode.png 370w,\n/static/fb1ba561585d7f99cc26ec7677f3c897/50383/decode.png 740w,\n/static/fb1ba561585d7f99cc26ec7677f3c897/73caa/decode.png 1110w,\n/static/fb1ba561585d7f99cc26ec7677f3c897/536c7/decode.png 1480w,\n/static/fb1ba561585d7f99cc26ec7677f3c897/540ab/decode.png 1977w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>For the decoding you may notice that I benchmarked 2 methods from <code class=\"language-text\">base64</code>: <code class=\"language-text\">decode_config</code> and <code class=\"language-text\">decode_config_slice</code>. The reason is that they have a <a href=\"https://github.com/marshallpierce/rust-base64/issues/195\">bug</a> in their implementation: <code class=\"language-text\">decode_config</code> allocates significantly more memory than it’s needed. But the difference in terms of performance is very small (around 10%). It was <a href=\"https://github.com/marshallpierce/rust-base64/commit/5c043f9b74114b3e9a3bb98b07ba917963b0b815\">fixed</a>, but not in the most efficient way, and still not published.</p>\n<h3 id=\"versus-java\" style=\"position:relative;\"><a href=\"#versus-java\" aria-label=\"versus java permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Versus Java</h3>\n<p>Let’s compare performance for 1K input Rust vs Java: and immediately — WOW!</p>\n<p>For encoding Java performs better than Rust O_O:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">method                       input  output  avg time\nbase64::encode_config         1002    1336      1078\ncrypto2::encode_with_config   1002    1336      1977\njdk::encode                   1002    1336      1913\nj.u.Base64.Encoder            1002    1336       872</code></pre></div>\n<p>And even ported almost 1-to-1 implementation is 2 times slower than Java.</p>\n<p>For decoding everything looks normal: ported implementation has comparable performance and Rust’s implementation is about 2 times faster than Java.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">method                       input  output  avg time\nbase64::decode_config         1336    1002      1163\nbase64::decode_config_slice   1336    1002      1075\ncrypto2::decode_with_config   1336    1002      4014\njdk::decode                   1336    1002      1985\nj.u.Base64.Decoder            1336    1002      1930</code></pre></div>\n<p>And the full table for different input sizes:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">method                       input  output  avg time\nbase64::encode_config           12      16        76\nbase64::encode_config           51      68       120\nbase64::encode_config          102     136       184\nbase64::encode_config          501     668       584\nbase64::encode_config         1002    1336      1078\ncrypto2::encode_with_config     12      16        67\ncrypto2::encode_with_config     51      68       145\ncrypto2::encode_with_config    102     136       274\ncrypto2::encode_with_config    501     668      1101\ncrypto2::encode_with_config   1002    1336      1977\njdk::encode                     12      16        70\njdk::encode                     51      68       138\njdk::encode                    102     136       262\njdk::encode                    501     668      1004\njdk::encode                   1002    1336      1913\nj.u.Base64.Encoder              12      16        46\nj.u.Base64.Encoder              51      68        86\nj.u.Base64.Encoder             102     136       128\nj.u.Base64.Encoder             501     668       446\nj.u.Base64.Encoder            1002    1336       872\n\nbase64::decode_config           16      12        85\nbase64::decode_config           68      51       119\nbase64::decode_config          136     102       174\nbase64::decode_config          668     501       584\nbase64::decode_config         1336    1002      1163\nbase64::decode_config_slice     16      12        76\nbase64::decode_config_slice     68      51       152\nbase64::decode_config_slice    136     102       165\nbase64::decode_config_slice    668     501       586\nbase64::decode_config_slice   1336    1002      1075\ncrypto2::decode_with_config     16      12        96\ncrypto2::decode_with_config     68      51       239\ncrypto2::decode_with_config    136     102       442\ncrypto2::decode_with_config    668     501      1934\ncrypto2::decode_with_config   1336    1002      4014\njdk::decode                     16      12        75\njdk::decode                     68      51       150\njdk::decode                    136     102       254\njdk::decode                    668     501      1007\njdk::decode                   1336    1002      1985\nj.u.Base64.Decoder              16      12        53\nj.u.Base64.Decoder              68      51       128\nj.u.Base64.Decoder             136     102       231\nj.u.Base64.Decoder             668     501       977\nj.u.Base64.Decoder            1336    1002      1930</code></pre></div>\n<h2 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>An unexpected result of Java outperforming Rust in encoding will please Java users :) Even though it’s totally possible for Java to outperform unmanaged code, it’s a rare case. Let’s celebrate :)</p>\n<p>I liked the opportunity to compare Java versus Rust. I rarely cross boundaries of my main platform (Scala, JDK). I will probably do it more in the future.</p>\n<p>Full criterion report is <a href=\"/data/charts/base64-rust/index.html\">here</a>. Source code is on <a href=\"https://github.com/dkomanov/rust-stuff/tree/4e80056ef990e70f64a7fe12986d14a881999818/base64_bench/benches\">GitHub</a>. Originally posted on <a href=\"https://dkomanov.medium.com/base64-encoding-performance-java-vs-rust-c59f438411f0\">Medium</a>. <a href=\"https://pixabay.com/vectors/train-bullet-speed-grey-red-309824/\">Cover image</a> by <a href=\"https://pixabay.com/users/clker-free-vector-images-3736/\">Clker-Free-Vector-Images</a> from <a href=\"https://pixabay.com/\">Pixabay</a> (plus my gimp madskillz).</p>","fields":{"slug":"/p/base64-encoding-performance-java-vs-rust/"},"frontmatter":{"rawDate":"2022-10-16T00:00:00.000Z","date":"October 16, 2022","title":"Base64 Encoding Performance: Java vs Rust","description":"Performance comparison of base64 encoding/decoding between base64, crypto2 and JDK implementations with some unexpected results!","tags":["rust","java","base64","benchmark","performance"],"canonicalUrl":"https://dkomanov.medium.com/base64-encoding-performance-java-vs-rust-c59f438411f0","cover":{"publicURL":"/static/82f1a70601c643c3f97ab206a1b9005f/cover.png"}}}},"pageContext":{"slug":"/p/base64-encoding-performance-java-vs-rust/","previous":{"fields":{"slug":"/p/base64-encoding-performance-jdk-vs-apache-commons/"}},"next":{"fields":{"slug":"/p/scala-serialization-2022/"}}}},"staticQueryHashes":["3675711862"]}