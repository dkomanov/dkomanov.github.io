{"componentChunkName":"component---src-templates-blog-post-js","path":"/p/replacing-hash-map-with-off-heap-hash-map-in-java/","result":{"data":{"markdownRemark":{"id":"a80e1020-b6d2-5589-adbb-ef4d285f0e2c","excerpt":"Wow, that’s the fifth (and I hope that last, famous last words) episode in my series “Benchmarking something that almost no one needs” :) I explored performance…","html":"<p>Wow, that’s the fifth (and I hope that last, famous last words) episode in my series “Benchmarking something that almost no one needs” :) I <a href=\"/p/map-performance-java-vs-scala\">explored performance</a> of java.util.HashMap vs scala.Map, and then tried to <a href=\"/p/replacing-hash-set-with-sorted-array-in-java\">replace</a> HashSet with sorted array and binary search, also storing this array off-heap. Then I went not only off-heap, but also out-of-process with <a href=\"/p/ultimate-off-heap-hash-set-using-redis\">Redis</a> and later on with <a href=\"/p/mysql-as-redis-vs-redis\">MySQL</a>.</p>\n<p>On the MySQL bit I hoped my strange interest in this topic will die off, but no… There was one thing I wanted to try and initially decided not to spend time on it. But since I spent some time on Redis and MySQL, which were completely out of the initial scope, why not to benchmark something that I actually wanted :)</p>\n<p>As always, doing more benchmarks I’m getting newer insights, this post isn’t an exception in this regard, I invalidated, in a way, benchmark results of <a href=\"/p/map-performance-java-vs-scala\">Map Performance: Java vs Scala</a>.</p>\n<h2 id=\"what-do-i-benchmark\" style=\"position:relative;\"><a href=\"#what-do-i-benchmark\" aria-label=\"what do i benchmark permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What do I benchmark?</h2>\n<p>The use case I benchmark in all these blog posts is this: I have a cache of ~1 million <a href=\"https://cr.openjdk.java.net/~iris/se/17/latestSpec/api/java.base/java/util/UUID.html\">UUIDs</a>. And for the simplicity sake we can say that this cache changes rarely, meaning that once in a while we can even recreate entire cache, so we may consider it a read only cache.</p>\n<p>Then I want to find out the memory footprint of my cache, and minimize it if possible. To quickly reiterate the memory footprint: UUID has 16 bytes of meaningful data, but actually takes 32 bytes on heap; HashMap multiplies it at least by 2, so 1M UUIDs will occupy at least 64MB on heap (actually a little bit more). Sorted array off-heap takes 16MB, but it’s performance is not as good.</p>\n<p>I mentioned <a href=\"https://openjdk.org/projects/valhalla/\">Valhalla Project</a> which will allow to reduce some overhead and HashMap will take less space. And I decided not to wait but implement simple HashMap off-heap and benchmark its performance.</p>\n<h2 id=\"off-heap-hashmap\" style=\"position:relative;\"><a href=\"#off-heap-hashmap\" aria-label=\"off heap hashmap permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Off-Heap HashMap</h2>\n<p>Good thing is I don’t need a generic solution, so I decided to implement <code class=\"language-text\">Map&lt;UUID, Integer></code> using off-heap memory (via <a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/jdk/internal/misc/Unsafe.java#L621\">Unsafe</a>). The simplest HashMap implementation would be an array of entries like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Entry</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> mostSignificantBits<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> leastSignificantBits<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>1M keys - array of 1M entries. The way we distribute keys is this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">int index = Math.abs(key.hashCode()) % entries.length;</code></pre></div>\n<p>If we have a collision, find an empty spot for entry, set <code class=\"language-text\">next</code> to that index, and when we search, we just need to iterate over all collisions to find (or not) the match. This way we store linked list in an array.</p>\n<p>The size of <code class=\"language-text\">Entry</code> is 28 bytes — 12 bytes overhead. We could probably save a byte of two. On the other side, it might be beneficial to add 4 bytes just to have 32-bytes entry, which will be aligned in memory nicely.</p>\n<h2 id=\"i-did-it-wrong\" style=\"position:relative;\"><a href=\"#i-did-it-wrong\" aria-label=\"i did it wrong permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>I Did It Wrong!</h2>\n<p>Because I was implementing HashMap, I suddenly realized, that the way I benchmarked before wasn’t right, because I didn’t benchmark cases with collisions (or it wasn’t consistent).</p>\n<p>The way I did it: on initialization phase I picked 10 random UUIDs from the map and then I ran benchmark with those 10 UUIDs. On one hand it basically tests certain spots in memory, so it’s always hot and cached. It might be ok if the use case very close to it. But I want to know performance not for the best case. So I came up with the idea of benchmarking against all keys, not just random 10. And the result is quite different from what I got before.</p>\n<h2 id=\"benchmarks\" style=\"position:relative;\"><a href=\"#benchmarks\" aria-label=\"benchmarks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Benchmarks!</h2>\n<p>I ran benchmarks for <code class=\"language-text\">java.lang.HashMap</code>, <code class=\"language-text\">scala.collection.immutable.Map</code> and 2 implementations of read only maps, one is on-heap and another is off-heap. The implementation of these maps is literally the same, except for the memory layout part. Basically, with the Project Valhalla I’d expect its performance and memory layout should be almost identical (in theory).</p>\n<p>As you may see on the chart, the performance of off-heap read only Map is very close to <code class=\"language-text\">java.util.HashMap</code>, very close.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/59718b20580983fe98d42710ffe6a018/476e1/hit-all-jdks.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.54054054054054%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcklEQVQoz22RQS8DQRTH9+5buPElJBKuPgE3LuIsblJxQSJRiYiIgwMSPUkQkWgQKaV6sJWujeKApd3qts3OzM7MX2Z2qkQneZt5s/P/zf+9Z4VhCEIIKKWQUnYIdDgTkIAOSAEWCTAWqQyWEAKt1RkoTJhccA2KvANE5bTWsTBAPaih0WzC4py3L/4GGSF1ZsD9y9iROhNMQ8j9JKg7p/dhGMD3fV2pJYQSRyB3E+DkMxZqRzy+fDsC5h3+A1InAfKY1PuIUqjW6ZK5AnKGMDMAUM8IxY9Dkh8FKnFpfxwWp4HnFdOq6Kdllvqo1cgO4ePLMT+Edq2FhXE8lbbBzQBawMidhZ2fQqCzdo8tJQt2t+BudKFvYQz2zouenwLUL27grXdjcLUfR4sFQMTTrWaLqM/3YHizF0uJNECUwgCpBGqZDMq5ZaSu0njLVfSLVAnzNqrnSezZ+3DP3jVQGag8vKJxuoYTJ4Xr4xLApOm9xDfNiFiCWUNOyAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Successful Lookup in Map of 1M items, all JDKs\"\n        title=\"Successful Lookup in Map of 1M items, all JDKs\"\n        src=\"/static/59718b20580983fe98d42710ffe6a018/50383/hit-all-jdks.png\"\n        srcset=\"/static/59718b20580983fe98d42710ffe6a018/1d79a/hit-all-jdks.png 185w,\n/static/59718b20580983fe98d42710ffe6a018/1efb2/hit-all-jdks.png 370w,\n/static/59718b20580983fe98d42710ffe6a018/50383/hit-all-jdks.png 740w,\n/static/59718b20580983fe98d42710ffe6a018/73caa/hit-all-jdks.png 1110w,\n/static/59718b20580983fe98d42710ffe6a018/536c7/hit-all-jdks.png 1480w,\n/static/59718b20580983fe98d42710ffe6a018/476e1/hit-all-jdks.png 1841w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>An interesting chart of successful lookup for all benchmarked sizes. We can see that the performance actually depends on the size, but it grows slowly (not for Scala, though).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9fc4597ed3660208ad7849596a66f9a7/dcb79/hit-all-sizes.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.972972972972975%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4UlEQVQoz5WR7W7DIAxF8/6PmTbKmrZDTfgIYHMmIFW7H5tUpIusiznYZogxoqqfqYCqoJIpgHeOaZowxjDknD8Ala4c0eRQSR1oV07jyLquDCJC1d+g51kFJTRaNIWXp0opUOoGHfhfRT1ZKTk0VaNelaLIkdedDh1SSs2kmb9VW5PokGiRGMgx4a3FGsN2vxGD75nt4a5Bjhnax4PlPHKbziynscfzzHX+YpkvmMVgLt+Y651tdbhtx7uA1I8pbxU+yfu+E/dIShlnPd6H5tvNtmHXlUVx1T9i69zR3avKHxyiJXmNW7YjAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Successful Lookup, all sizes, openjdk-17\"\n        title=\"Successful Lookup, all sizes, openjdk-17\"\n        src=\"/static/9fc4597ed3660208ad7849596a66f9a7/50383/hit-all-sizes.png\"\n        srcset=\"/static/9fc4597ed3660208ad7849596a66f9a7/1d79a/hit-all-sizes.png 185w,\n/static/9fc4597ed3660208ad7849596a66f9a7/1efb2/hit-all-sizes.png 370w,\n/static/9fc4597ed3660208ad7849596a66f9a7/50383/hit-all-sizes.png 740w,\n/static/9fc4597ed3660208ad7849596a66f9a7/73caa/hit-all-sizes.png 1110w,\n/static/9fc4597ed3660208ad7849596a66f9a7/536c7/hit-all-sizes.png 1480w,\n/static/9fc4597ed3660208ad7849596a66f9a7/dcb79/hit-all-sizes.png 1700w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>For failed lookups (misses) performance is pretty much stable (not for Scala). It could be that iteration over all keys decreases the efficiency of memory caches, and for misses we use static list of 10 UUIDs. Maybe I need to generate same number of UUIDs and iterate over it…</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2528417349de2a37688f74b0078444e8/2af5b/miss-all-sizes.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.513513513513516%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA6ElEQVQoz32Q604EMQiF5/1fU11/OHGnLaU34BjaGV2NSnICLeUDurXWMMaAmUFV/5e/mQJUBSqrrreG19sN+75jc5iI/A38BaKDoT1DR4UZ0Cvj5flpAR3mUC+WB5Do2UA6tJcF6Lw0+hziemtqcyC3T+C8MP2SNkDKknpe8dMMq+kFc7/17t0UMgbovoOOHXR/A4V3UAygmECJUIiRPQ4BdBxIx4HKPCGP2uZ6IvNjS0qoRNOXGFEpoaaIEgPaGWe/zxk1E5gIPtC3Ca+DJ/SMr29wq60hxAibKwJcCuxcmZln3QVz4AftsSYt1c0lVQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Failed Lookup, all sizes, openjdk-17\"\n        title=\"Failed Lookup, all sizes, openjdk-17\"\n        src=\"/static/2528417349de2a37688f74b0078444e8/50383/miss-all-sizes.png\"\n        srcset=\"/static/2528417349de2a37688f74b0078444e8/1d79a/miss-all-sizes.png 185w,\n/static/2528417349de2a37688f74b0078444e8/1efb2/miss-all-sizes.png 370w,\n/static/2528417349de2a37688f74b0078444e8/50383/miss-all-sizes.png 740w,\n/static/2528417349de2a37688f74b0078444e8/73caa/miss-all-sizes.png 1110w,\n/static/2528417349de2a37688f74b0078444e8/536c7/miss-all-sizes.png 1480w,\n/static/2528417349de2a37688f74b0078444e8/2af5b/miss-all-sizes.png 1697w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>My simplest implementation of read-only Map stored off-heap is better memory-wise and very close in terms of performance to a <code class=\"language-text\">java.util.HashMap</code>, which is cool. If memory and GC pressure is important in the application, I’d probably consider moving to this data structure to improve resiliency of the application.</p>\n<p>To conclude the series, in short:</p>\n<p>Performance-wise: <code class=\"language-text\">java.util.HashMap</code> ~ off-heap HashMap > <code class=\"language-text\">mutable.HashMap</code> > <code class=\"language-text\">immutable.Map</code> > <code class=\"language-text\">Array&lt;UUID></code> > Redis > MySQL.</p>\n<p>Memory-wise: <code class=\"language-text\">Array&lt;UUID></code> &#x3C; off-heap HashMap &#x3C; <code class=\"language-text\">java.util.HashMap</code>/<code class=\"language-text\">mutable.HashMap</code> &#x3C; Redis ~ MySQL.</p>\n<p>It’s actually wonderful that such topic has so many ways to explore both in depth and in breadth. But I have to stop somewhere, and I guess this is a good place, where I did an virtual experiment how would it work with Valhalla, and I hope it will be something like it.</p>\n<p>Play with charts <a href=\"/charts/offheap-hashmap\">here</a>. Source code is on <a href=\"https://github.com/dkomanov/stuff/commit/b28f52a4540aafd247a21fd31865a823943e0338\">GitHub</a>. Originally posted on <a href=\"https://dkomanov.medium.com/replacing-hashmap-with-off-heap-hashmap-in-java-ffb560e07b5\">Medium</a>. <a href=\"https://pixabay.com/photos/wheel-loader-wheel-cat-938m-heap-2580470/\">Cover image</a> by <a href=\"https://pixabay.com/users/ricobino-1987569/\">Rico S.</a> from <a href=\"https://pixabay.com/\">Pixabay</a>.</p>","fields":{"slug":"/p/replacing-hash-map-with-off-heap-hash-map-in-java/"},"frontmatter":{"rawDate":"2022-09-08T00:00:00.000Z","date":"September 08, 2022","title":"Replacing HashMap with Off-Heap HashMap in Java?","description":"Implementing a simple read only HashMap stored off-heap in Java and benchmarking it against java.util.HashMap!","tags":["java","hashmap","benchmark","performance","memory","offheap"],"canonicalUrl":"https://dkomanov.medium.com/replacing-hashmap-with-off-heap-hashmap-in-java-ffb560e07b5","cover":{"publicURL":"/static/e050238e43a5d71cfe900e54561dd466/cover.jpg"}}}},"pageContext":{"slug":"/p/replacing-hash-map-with-off-heap-hash-map-in-java/","previous":{"fields":{"slug":"/p/mysql-as-redis-vs-redis/"}},"next":{"fields":{"slug":"/p/base64-encoding-performance-jdk-vs-apache-commons/"}}}},"staticQueryHashes":["3675711862"]}