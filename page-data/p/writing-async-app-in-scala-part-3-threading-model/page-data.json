{"componentChunkName":"component---src-templates-blog-post-js","path":"/p/writing-async-app-in-scala-part-3-threading-model/","result":{"data":{"markdownRemark":{"id":"d1f1da3c-5be8-5e0a-9410-bb0ab21c8f13","excerpt":"Part 1. Coding.  Part 2. Exception Handling.  Part 3. Threading Model.  Part 4. Rewriting Existing App.  Part 5. What’s next? In previous parts we avoided the…","html":"<blockquote>\n<p><a href=\"/p/writing-async-app-in-scala-part-1-coding\">Part 1. Coding.</a> <br>\n<a href=\"/p/writing-async-app-in-scala-part-2-exception-handling\">Part 2. Exception Handling.</a> <br>\nPart 3. Threading Model. <br>\nPart 4. Rewriting Existing App. <br>\nPart 5. What’s next?</p>\n</blockquote>\n<p>In previous parts we avoided the question of which <code class=\"language-text\">ExecutionContext</code> we should use. Finally, we got to it! In this part I’m going to cover a lot of different topics around multi-threading. Let’s start right away!</p>\n<h2 id=\"how-many-threads-should-we-use\" style=\"position:relative;\"><a href=\"#how-many-threads-should-we-use\" aria-label=\"how many threads should we use permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How many threads should we use?</h2>\n<p>One interesting thing that async programming provides to us is an ability to use a small number of threads, close to the number of <a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html#availableProcessors()\">available CPUs</a>. Why is it cool?</p>\n<ol>\n<li>Smaller memory consumption: <a href=\"https://docs.oracle.com/en/java/javase/14/docs/specs/man/java.html\">by default</a> thread allocates 1 megabyte of memory for stack; minimum is different on different platforms, for example, on 64-bit Linux openjdk14 it’s 136K.</li>\n<li>Better resilience as there is no struggle for CPU resources. If you have more, it’s possible that more than CPU number threads will awake at the same time and will try to do something.</li>\n<li>(the most significant one) It brings peace to a soul of a control freak :D</li>\n</ol>\n<p>What kinds of operations do we need to perform in our application:</p>\n<ul>\n<li>HTTP or whatever server performs some IO for incoming/outgoing requests.</li>\n<li>RPC/HTTP clients do some IO.</li>\n<li>Database driver does IO.</li>\n<li>And our application code orchestrates it all.</li>\n</ul>\n<p>Now we need to decide how do we want to split all these operations among available CPUs.</p>\n<p>NB: I left out one more kind of operations, namely - local disk IO (logging, file cache, etc.) I hope I’d be able to write a dedicated blog post about logging in async world.</p>\n<h3 id=\"io-vs-application-code\" style=\"position:relative;\"><a href=\"#io-vs-application-code\" aria-label=\"io vs application code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IO vs application code</h3>\n<p>What are the differences between the code of our application and other stuff? I mentioned IO not by accident. For example, what does an HTTP server?</p>\n<ul>\n<li>Listen for incoming connection.</li>\n<li>Reads some chunk of a request. This is an async part.</li>\n<li>Parses an HTTP request: it requires some CPU to split raw bytes into nice data object with protocol version, method, headers, etc.</li>\n<li>Passes control to an application: this is our part.</li>\n<li>Writes back a response, which is mostly async.</li>\n</ul>\n<p>As you may see, mostly HTTP server waits for bytes to read or that bytes are written. Therefore, it needs very short time slots on the CPU. The same applies to all mostly IO code: HTTP client (which is essentially very similar to server), database drivers, etc.</p>\n<p>An application, on the other hand, may do slightly more (just as an example):</p>\n<ul>\n<li>Parse request body as JSON.</li>\n<li>Convert JSON to some domain object.</li>\n<li>Convert domain object to some other object in order to serialize it as JSON and send via RPC.</li>\n<li>Parse JSON of RPC response, mix up with domain object.</li>\n<li>Prepare a query to the database.</li>\n<li>Parse response from database (convert to domain model or even parse JSON, stored in DB).</li>\n<li>Collect everything together, serialize to JSON and send back to a client.</li>\n</ul>\n<p>So, an application orchestrates requests to multiple servers, does parsing and serialization (which are CPU-bound operations), converts one representation to another.</p>\n<h3 id=\"single-pool-vs-separate-io-pool\" style=\"position:relative;\"><a href=\"#single-pool-vs-separate-io-pool\" aria-label=\"single pool vs separate io pool permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Single pool vs separate IO pool</h3>\n<p>As we defined what is happening inside an application, we can reason about how to handle it.</p>\n<p>Generally, there are two main approaches: share threads for all operations or allocate separate thread pools for different kinds of operations.</p>\n<p>What is a trade-off for having a single thread pool? In a single thread pool all tasks will be submitted to a single queue, which means that tasks should wait its turn regardless of the time it needs.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 164px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/83d48aa3c165e236159abe86a6d6d151/2001c/queue.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 194.5121951219512%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAnCAYAAAAPZ2gOAAAACXBIWXMAAAsSAAALEgHS3X78AAADTElEQVRIx62W6W5aMRCF8/7P0R+tVKVqlTSq2rRhLYQEyhbWLISw71sIkDC9nytXvlwTqFRLo7meMcfjMzM2B7JlrNdrl9533cE+i1erlUxnM3l6WshisVCa+XK58mx6sAtsOp2JLxSVq3xJwtFLOQtGJBS5kHyxLL5gVPqDoTtCPmzH09+tdkfOL5NSb7Qc/Uu+nQUlEktIq9OV6EVCKtWaWvfyYhxZg9oAO92eJDM5efPug5z6QhL8GZNA+Fzevv/kAMfVRgrQjNBGvp63nUi++8IOcF8CDtjHz1/lLBCRwWAkP/xhI8KXP4BHR0cSiURcRhNwsVxKKpOXbK74VzJXBcVpMn0lj49zN4f5fF76/f6rUe4arizXajWnDJ62JgVtRm4O7J46vL+/d8J+fBWQ0e0NpOlknDKCv/F4Yi/sarXqArQJA86+nPolFk+qbMfiKVeUWrYCbo7n52fP0dcWLj2Am/xoDvW3BtY2U3uOrMrE6dVSqSS3t7dyc3PjEmxwbvPd3d1JLpfzAo5GI2k2m9asTiYTOT4+dhIztfqpGA8gi6nNTqejgLW0222pVCoSCoVUlMxNf7fblUwmY0/KYDBQgCzSwpwGYC3a5u/1et4IZ849BxeETyT4kYeHB8VdLBZTnDHXPtbV63VJpVJewOFwKI1GYyuH9D6b7s3hfD5XkWxyhLAR2US3Wi0Px+Vy2QtIPQHIsQuFgkcoKTSJM+3M8XkAx+OxioJ3BDsRozkmwrdp10LBX19f2wG3cbhrWDkEkIzpkU6nJZFISDweV5rNfD6fyrbf71dH1QOsnYB8U7AARKNRFUU2m1UcoymhnYD/9cjUGi3GJUEbasGuxbRrYT3RWltP3xy6HLQwJ5ObdoT11ixTGjjoS4pVC70KFYChmZt++hvfP7UeV9vh4aE6tm3Q39bWo+Jx6stBa7gtFotKm3Y0CbFesLQex+VIm4Kd6Lb5EWvZsBOcmBwBQrJOTk6UNjnmouAOtV5f8LSNQxIWCARc63fWIU3ObUOmqSu0Fv1Ibdr1Wuv1RYHi4MebwlH1q2fzqbIhY/seea9XD1KJyvyRfvUA1jc1xOtXD83c9PNQcTMd2P4cESVZ2xTsJIbit/mx/wZ3UJQIOSkEyQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Mix of short and long tasks in a queue\"\n        title=\"Mix of short and long tasks in a queue\"\n        src=\"/static/83d48aa3c165e236159abe86a6d6d151/2001c/queue.png\"\n        srcset=\"/static/83d48aa3c165e236159abe86a6d6d151/2001c/queue.png 164w\"\n        sizes=\"(max-width: 164px) 100vw, 164px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>As you may see, multiple small IO tasks may wait in a queue until some big JSON is parsed, which postpones a bit a response for a client.</p>\n<p>On the other hand, if a thread pool is implemented properly, the locality of data in a thread will enable faster execution. For example, when an HTTP server read a chunk of bytes, it sits in a CPU cache, and if parsing code will be executed right after a read operation, it will work with a cached data as opposed to working with a cold memory (for example, see latencies for accessing caches and memory for <a href=\"https://www.7-cpu.com/cpu/Skylake.html\">i7 skylake</a>.)</p>\n<p>There is no silver bullet. Depending on your application, on its actual workload, the answer may be different. Measure the time spent in your application code, decide what would be better for you.</p>\n<h2 id=\"blocking-code\" style=\"position:relative;\"><a href=\"#blocking-code\" aria-label=\"blocking code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Blocking code</h2>\n<p>Obviously, in async applications we should avoid using blocking code. But what if our database doesn’t have a working async driver? What if the only way to use it is a blocking JDBC?</p>\n<p>It’s very important to remember to not mix a non-blocking code with a blocking one. As I showed in a previous part, consequences may be very tragic for responsiveness and overall throughput.</p>\n<p>What to do? Use a separate thread pool! What size to choose? The number of maximum SQL connections you’re willing to use from a single application instance. Is it safe? Let’s try to find out!</p>\n<p>The first approach to write a DAO:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">implicit</span> <span class=\"token keyword\">val</span> blockingExecutionContext <span class=\"token operator\">=</span>\n  ExecutionContext<span class=\"token punctuation\">.</span>fromExecutorService<span class=\"token punctuation\">(</span>Executors<span class=\"token punctuation\">.</span>newFixedThreadPool<span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">class</span> MyDao<span class=\"token punctuation\">(</span>jdbcTemplate<span class=\"token operator\">:</span> JdbcTemplate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">implicit</span> ec<span class=\"token operator\">:</span> ExecutionContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> get<span class=\"token punctuation\">(</span>id<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Future<span class=\"token punctuation\">[</span>Option<span class=\"token punctuation\">[</span>RichDomainObject<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n    Future<span class=\"token punctuation\">(</span>getBlocking<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">def</span> getBlocking<span class=\"token punctuation\">(</span>id<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span>RichDomainObject<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n    jdbcTemplate<span class=\"token punctuation\">.</span>queryForObject<span class=\"token punctuation\">(</span>\n      <span class=\"token string\">\"SELECT blob FROM table WHERE id = ?\"</span><span class=\"token punctuation\">,</span>\n      Array<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      rs <span class=\"token keyword\">=></span> parseJson<span class=\"token punctuation\">(</span>rs<span class=\"token punctuation\">.</span>getString<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">def</span> parseJson<span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> RichDomainObject <span class=\"token operator\">=</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Here we create a thread pool with 50 threads, and then we just submit a <code class=\"language-text\">Future</code> to this thread pool, and everything is done there. Good? Kind of. It’s working unless… Do you see the part where we need to parse a JSON from a blob column in a database? This part may be problematic. Imagine, our service got a sudden spike, and we got a lot of requests in parallel. It’s quite possible, that at the same time more than a CPU number threads will get a response from a database and will start to parse JSON in parallel. JSON parsing is a CPU-bound operation, so threads will fight for CPU resources which will cause elevated response times, etc. We don’t want it. What to do?</p>\n<p>Let’s be a little bit smart about it:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> RobustDao<span class=\"token punctuation\">(</span>jdbcTemplate<span class=\"token operator\">:</span> JdbcTemplate<span class=\"token punctuation\">,</span> blockingEc<span class=\"token operator\">:</span> ExecutionContext<span class=\"token punctuation\">,</span> applicationEc<span class=\"token operator\">:</span> ExecutionContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> get<span class=\"token punctuation\">(</span>id<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Future<span class=\"token punctuation\">[</span>Option<span class=\"token punctuation\">[</span>RichDomainObject<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    Future<span class=\"token punctuation\">(</span>getBlocking<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>blockingEc<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>blob <span class=\"token keyword\">=></span> blob<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>parseJson<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>applicationEc<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">def</span> getBlocking<span class=\"token punctuation\">(</span>id<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n    jdbcTemplate<span class=\"token punctuation\">.</span>queryForObject<span class=\"token punctuation\">(</span>\n      <span class=\"token string\">\"SELECT blob FROM table WHERE id = ?\"</span><span class=\"token punctuation\">,</span>\n      Array<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      rs <span class=\"token keyword\">=></span> rs<span class=\"token punctuation\">.</span>getString<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// no parsing, just simple data extraction</span>\n    <span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">def</span> parseJson<span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> RichDomainObject <span class=\"token operator\">=</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Here we split a query into 2 parts:</p>\n<ol>\n<li>Execute query and extract the blob column. It should be very quick in terms of CPU. So multiple concurrent executions won’t lead to a fight for CPU.</li>\n<li>Parse JSON into a domain object. This part will be executed in another <code class=\"language-text\">ExecutionContext</code>, which should be limited to a number of threads less or equal to a number of CPUs.</li>\n</ol>\n<p>By doing so we increase the resilience of our application to high traffic. Just to mention, that it’s not a final solution, for peak traffic you still need to scale up your cluster, but this solution will give you time to do that, and servers won’t die.</p>\n<h2 id=\"direct-executioncontext\" style=\"position:relative;\"><a href=\"#direct-executioncontext\" aria-label=\"direct executioncontext permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Direct ExecutionContext</h2>\n<p>In guava there is a <a href=\"https://guava.dev/releases/19.0/api/docs/com/google/common/util/concurrent/MoreExecutors.html#directExecutor()\">directExecutor</a> which simply executes runnable immediately in the same thread. Same idea in Scala would look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\">ExecutionContext<span class=\"token punctuation\">.</span>fromExecutor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>runnable<span class=\"token operator\">:</span> Runnable<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> runnable<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Do we really need it? By definition, it doesn’t provide any concurrency. And still, I’d argue it’s a very important piece of our async application. Let’s understand — why?</p>\n<h3 id=\"how-does-executioncontext-work\" style=\"position:relative;\"><a href=\"#how-does-executioncontext-work\" aria-label=\"how does executioncontext work permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How does ExecutionContext work?</h3>\n<p><a href=\"https://www.scala-lang.org/api/current/scala/concurrent/ExecutionContext.html\">ExecutionContext</a> is a simple abstraction:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">trait</span> ExecutionContext <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> execute<span class=\"token punctuation\">(</span>runnable<span class=\"token operator\">:</span> Runnable<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span>\n  <span class=\"token keyword\">def</span> reportFailure<span class=\"token punctuation\">(</span>cause<span class=\"token operator\">:</span> Throwable<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Usually, there is a some kind of thread pool behind <code class=\"language-text\">ExecutionContext</code>: one of the <a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/Executors.html\">ExecutorService</a> provided by JDK (FixedThreadPool, ForkJoinPool, etc.)</p>\n<p>Any thread pool consists of 2 parts: queue for incoming tasks and a pool of threads. In order to run <code class=\"language-text\">map</code>/<code class=\"language-text\">flatMap</code>/<code class=\"language-text\">onComplete</code> of a <code class=\"language-text\">Future</code>, we need to submit a task (Runnable) to an <code class=\"language-text\">ExecutorService</code>. Submit consists of 2 operations: <a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/BlockingQueue.html#offer(E)\">offer</a> to a BlockingQueue and subsequent <a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/BlockingQueue.html#take()\">take</a> from it.</p>\n<h3 id=\"simple-example\" style=\"position:relative;\"><a href=\"#simple-example\" aria-label=\"simple example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Simple example</h3>\n<p>Let’s consider this completely foobar-ish example.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> rpcCall<span class=\"token operator\">:</span> Future<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span>\n\nrpcCall\n  <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">'_'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span>filter<span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span>map <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> Array<span class=\"token punctuation\">(</span>single<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> single\n    <span class=\"token keyword\">case</span> Array<span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">,</span> second<span class=\"token annotation punctuation\">@_</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> first\n    <span class=\"token keyword\">case</span> Array<span class=\"token punctuation\">(</span>first<span class=\"token annotation punctuation\">@_</span><span class=\"token punctuation\">,</span> second<span class=\"token punctuation\">,</span> third<span class=\"token annotation punctuation\">@_</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> third\n    <span class=\"token keyword\">case</span> _ <span class=\"token keyword\">=></span> <span class=\"token string\">\"\"</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>value <span class=\"token keyword\">=></span> s<span class=\"token string\">\"&lt;p>$value&lt;/p>\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span>recoverFilter<span class=\"token punctuation\">(</span><span class=\"token string\">\"&lt;p>invalid&lt;/p>\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>What I want to show here is that we don’t always write an optimal code, sometimes we write something like this just because it’s fairly simple and easy to read all in one place. But there’s a micro-problem: each of these functions takes an implicit <code class=\"language-text\">ExecutionContext</code> and submits a task to a thread pool. Is it bad? Let’s benchmark it!</p>\n<h3 id=\"benchmark\" style=\"position:relative;\"><a href=\"#benchmark\" aria-label=\"benchmark permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Benchmark!</h3>\n<p>The code of benchmark is <a href=\"https://github.com/dkomanov/stuff/blob/master/src/com/komanov/future/jmh/FutureMapBenchmark.scala\">here</a>. We do a very simple benchmark:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">var</span> future <span class=\"token operator\">=</span> Future<span class=\"token punctuation\">.</span>successful<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>_ <span class=\"token keyword\">&lt;-</span> <span class=\"token number\">1</span> to <span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  future <span class=\"token operator\">=</span> future<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>v <span class=\"token keyword\">=></span> v <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\nrequire<span class=\"token punctuation\">(</span>Await<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">,</span> <span class=\"token number\">10.</span>seconds<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>And we measure this piece of code with different execution contexts: <a href=\"https://docs.scala-lang.org/overviews/core/futures.html#the-global-execution-context\">global</a> which is backed by ForkJoinPool, single-threaded <code class=\"language-text\">ExecutionContext</code> which is backed by <a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/Executors.html#newSingleThreadExecutor()\">Executors.newSingleThreadExecutor</a> and direct <code class=\"language-text\">ExecutionContext</code>. The result table is below (units are micro-seconds):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Benchmark                            Mode  Cnt   Score    Error  Units\nFutureMapBenchmark.direct            avgt    5   4.056 ±  0.163  us/op\nFutureMapBenchmark.realGlobal        avgt    5  62.999 ± 17.757  us/op\nFutureMapBenchmark.realSingleThread  avgt    5  18.046 ±  0.722  us/op\nFutureMapBenchmark.smart             avgt    5   1.693 ±  0.100  us/op</code></pre></div>\n<p>As you may see, direct wins easily as it doesn’t do any context switching, no queue operations, etc. <code class=\"language-text\">global</code> loses to a single threaded pretty significantly, because, yes, both have queue operations, but in case of single-threaded there are no context switches, everything is happening in a single thread.</p>\n<p>But what is <code class=\"language-text\">smart</code>? It’s a very neat optimization, here is an <code class=\"language-text\">Future[T]</code> extension method:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> smartMap<span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> T <span class=\"token keyword\">=></span> U<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">implicit</span> ec<span class=\"token operator\">:</span> ExecutionContext<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Future<span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">.</span>isCompleted<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">.</span>isSuccess<span class=\"token punctuation\">)</span>\n      wrap<span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span>\n      future<span class=\"token punctuation\">.</span>asInstanceOf<span class=\"token punctuation\">[</span>Future<span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    future<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ec<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Inside <code class=\"language-text\">smartMap</code> we check whether <code class=\"language-text\">Future</code> is resolved or not. If it’s resolved we can execute a mapping function right away, without submitting it to an <code class=\"language-text\">ExecutionContext</code>. As you may see from the benchmark, there is a cost of submitting task to an <code class=\"language-text\">ExecutionContext</code>. Here is what is happening on submit effectively (real code is slightly more complicated, you’re welcome to explore it by yourself):</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> map<span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> T <span class=\"token keyword\">=></span> U<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">implicit</span> ec<span class=\"token operator\">:</span> ExecutionContext<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Future<span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">val</span> promise <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isCompleted<span class=\"token punctuation\">)</span> <span class=\"token comment\">// in real code this is an atomic operation + pattern matching</span>\n    <span class=\"token comment\">// even if it's completed, callback is submitted to ExecutionContext</span>\n    ec<span class=\"token punctuation\">.</span>execute<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> <span class=\"token punctuation\">{</span>\n      f<span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">else</span>\n    registerCallback<span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ec<span class=\"token punctuation\">)</span>\n  promise<span class=\"token punctuation\">.</span>future\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And all this complexity could be avoided by using <code class=\"language-text\">smartMap</code>.</p>\n<p>Obviously, there is a reason, why the default behavior of a <code class=\"language-text\">Future</code> is like this. In general case such optimizations (direct executor and smartMap) could lead to a <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html\">starvation</a> if all operations on futures are too long. However, if we know the load profile of our application we can apply such optimizations for a pretty good benefit.</p>\n<p>Regarding <code class=\"language-text\">smartMap</code>. I put it as an example, in my real code I don’t use it, because we don’t have that many possibly-redundant operations, and usage of non-standard extensions would lead to confusion as it would be kind of necessary then to avoid using standard ones, which complicates life much more than gain we get from it.</p>\n<h3 id=\"how-to-use-direct-executioncontext\" style=\"position:relative;\"><a href=\"#how-to-use-direct-executioncontext\" aria-label=\"how to use direct executioncontext permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How to use direct ExecutionContext</h3>\n<p>Usage of direct ExecutionContext brings some new considerations. Consider this example:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> rpcCall<span class=\"token operator\">:</span> Future<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span>\n<span class=\"token keyword\">def</span> daoCall<span class=\"token punctuation\">(</span>id<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Future<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span>\n<span class=\"token keyword\">def</span> extractId<span class=\"token punctuation\">(</span>idStr<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Future<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span>\n<span class=\"token keyword\">def</span> convertDbValue<span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Future<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span>\n\n<span class=\"token keyword\">import</span> directExecutionContext\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n  idStr <span class=\"token keyword\">&lt;-</span> rpcCall\n  id <span class=\"token keyword\">&lt;-</span> extractId<span class=\"token punctuation\">(</span>idStr<span class=\"token punctuation\">)</span> <span class=\"token comment\">// executed in RPC execution context</span>\n  valueFromDb <span class=\"token keyword\">&lt;-</span> daoCall<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n  value <span class=\"token keyword\">&lt;-</span> convertDbValue<span class=\"token punctuation\">(</span>valueFromDb<span class=\"token punctuation\">)</span> <span class=\"token comment\">// executed in DAO execution context</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">yield</span> value <span class=\"token comment\">// executed in DAO execution context</span></code></pre></div>\n<p>With naive usage of <code class=\"language-text\">direct</code> we may encounter very much undesired consequences: execution will jump from one <code class=\"language-text\">ExecutionContext</code> to another. It’s all under the assumption that all real async operations have their own execution contexts. If you use single shared <code class=\"language-text\">ExecutionContext</code> there is no such problem.</p>\n<p>To tackle this problem, what we need to do is to ensure that in all places where we use non-application <code class=\"language-text\">ExecutionContext</code> we have to move <code class=\"language-text\">Future</code> back to application <code class=\"language-text\">ExecutionContext</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> RpcClient<span class=\"token punctuation\">(</span>ownEc<span class=\"token operator\">:</span> ExecutionContext<span class=\"token punctuation\">,</span> appEc<span class=\"token operator\">:</span> ExecutionContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> call<span class=\"token operator\">:</span> Future<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n    Future<span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ownEc<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>identity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>appEc<span class=\"token punctuation\">)</span> <span class=\"token comment\">// here we move back to an application execution context</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>By doing this trick the next transformation (submitted to <code class=\"language-text\">direct</code>) on a <code class=\"language-text\">Future</code> returned by <code class=\"language-text\">RpcClient</code> will be executed in an application <code class=\"language-text\">ExecutionContext</code>. If you do it everywhere you’ll be able to utilize the superiority of a direct <code class=\"language-text\">ExecutionContext</code>.</p>\n<p>As a result of using <code class=\"language-text\">directExecutionContext</code> we almost never have <code class=\"language-text\">implicit ec: ExecutionContext</code>, because in order to make sure that correct <code class=\"language-text\">ExecutionContext</code> will be used, we have to completely separate async resources from application code. So, <code class=\"language-text\">ExecutionContext</code> for the application code is used along with another <code class=\"language-text\">ExecutionContext</code> in a resource just as in an example above. And in all classes that do business logic of the application we can just import <code class=\"language-text\">directExecutionContext</code> and concentrate on the business-related code, not on the multi-threading aspect of the code.</p>\n<h3 id=\"neat-side-effect\" style=\"position:relative;\"><a href=\"#neat-side-effect\" aria-label=\"neat side effect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Neat side effect</h3>\n<p>It’s known that stack trace is almost useless in async applications. Let’s find out how badly via simple <a href=\"https://github.com/dkomanov/stuff/blob/master/src/com/komanov/future/examples/ExceptionDemo.scala\">demo</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> stackTrace<span class=\"token punctuation\">(</span><span class=\"token keyword\">implicit</span> ec<span class=\"token operator\">:</span> ExecutionContext<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Any</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  Await<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">(</span>\n    Future<span class=\"token punctuation\">.</span>successful<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>v <span class=\"token keyword\">=></span> v <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span>flatMap<span class=\"token punctuation\">(</span>v <span class=\"token keyword\">=></span> Future<span class=\"token punctuation\">.</span>successful<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span>map <span class=\"token punctuation\">{</span> v <span class=\"token keyword\">=></span>\n        <span class=\"token keyword\">new</span> IllegalStateException<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>printStackTrace<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        v\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">10.</span>seconds\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nstackTrace<span class=\"token punctuation\">(</span>scala<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>ExecutionContext<span class=\"token punctuation\">.</span>Implicits<span class=\"token punctuation\">.</span>global<span class=\"token punctuation\">)</span>\nstackTrace<span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>komanov<span class=\"token punctuation\">.</span>future<span class=\"token punctuation\">.</span>directExecutionContext<span class=\"token punctuation\">)</span></code></pre></div>\n<p>For <code class=\"language-text\">global</code> there will stack trace like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">java.lang.IllegalStateException\n    at com.komanov.future.examples.ExceptionDemo$.$anonfun$stackTrace$3(ExceptionDemo.scala:14)\n    at scala.runtime.java8.JFunction1$mcII$sp.apply(JFunction1$mcII$sp.java:23)\n    at scala.util.Success.$anonfun$map$1(Try.scala:255)\n    at scala.util.Success.map(Try.scala:213)\n    at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)\n    at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)\n    at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)\n    at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)\n    at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)\n    at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n    at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n    at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n    at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)</code></pre></div>\n<p>And for <code class=\"language-text\">direct</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">java.lang.IllegalStateException\n    at com.komanov.future.examples.ExceptionDemo$.$anonfun$stackTrace$3(ExceptionDemo.scala:14)\n    at scala.runtime.java8.JFunction1$mcII$sp.apply(JFunction1$mcII$sp.java:23)\n    at scala.util.Success.$anonfun$map$1(Try.scala:255)\n    at scala.util.Success.map(Try.scala:213)\n    at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)\n    at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)\n    at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)\n    at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)\n    at com.komanov.future.package$DirectExecutor.execute(package.scala:29)\n    at scala.concurrent.impl.ExecutionContextImpl.execute(ExecutionContextImpl.scala:24)\n    at scala.concurrent.impl.CallbackRunnable.executeWithValue(Promise.scala:72)\n    at scala.concurrent.impl.Promise$DefaultPromise.dispatchOrAddCallback(Promise.scala:316)\n    at scala.concurrent.impl.Promise$DefaultPromise.onComplete(Promise.scala:307)\n    at scala.concurrent.impl.Promise.transform(Promise.scala:33)\n    at scala.concurrent.impl.Promise.transform$(Promise.scala:31)\n    at scala.concurrent.impl.Promise$DefaultPromise.transform(Promise.scala:187)\n    at scala.concurrent.Future.map(Future.scala:292)\n    at scala.concurrent.Future.map$(Future.scala:292)\n    at scala.concurrent.impl.Promise$DefaultPromise.map(Promise.scala:187)\n    at com.komanov.future.examples.ExceptionDemo$.stackTrace(ExceptionDemo.scala:13)\n    at com.komanov.future.examples.ExceptionDemo$.delayedEndpoint$com$komanov$future$examples$ExceptionDemo$1(ExceptionDemo.scala:22)\n    at com.komanov.future.examples.ExceptionDemo$delayedInit$body.apply(ExceptionDemo.scala:6)\n    at scala.Function0.apply$mcV$sp(Function0.scala:39)\n    at scala.Function0.apply$mcV$sp$(Function0.scala:39)\n    at scala.runtime.AbstractFunction0.apply$mcV$sp(AbstractFunction0.scala:17)\n    at scala.App.$anonfun$main$1$adapted(App.scala:80)\n    at scala.collection.immutable.List.foreach(List.scala:392)\n    at scala.App.main(App.scala:80)\n    at scala.App.main$(App.scala:78)\n    at com.komanov.future.examples.ExceptionDemo$.main(ExceptionDemo.scala:6)\n    at com.komanov.future.examples.ExceptionDemo.main(ExceptionDemo.scala)</code></pre></div>\n<p>As you may see, it has much more information. This example has only 2 nesting levels, but it’s clear from this example, that with <code class=\"language-text\">directExecutionContext</code> we get the stack trace from the last async operation, which is not as good as in blocking app, but slightly better than non-direct.</p>\n<h2 id=\"a-final-look\" style=\"position:relative;\"><a href=\"#a-final-look\" aria-label=\"a final look permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A Final Look</h2>\n<p>So, at the end, how many threads are we going to use? And how many <code class=\"language-text\">ExecutionContext</code>s? Options vary, but there are 2 opposite cases: one thread pool/ExecutionContext for everything and multiple pools, possibly one per each IO entity. Let’s explore both possibilities.</p>\n<h3 id=\"single-shared-thread-pool\" style=\"position:relative;\"><a href=\"#single-shared-thread-pool\" aria-label=\"single shared thread pool permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Single shared thread pool</h3>\n<p>A single thread pool for the application code and all IO code is possible. For achieving that you need use only non-blocking libraries with an ability to specify (override) a thread pool. In this case everything is pretty simple, you have only 2 <code class=\"language-text\">ExecutionContext</code>s: direct and an <code class=\"language-text\">ExecutionContext</code> backed by the single thread pool for async stuff.</p>\n<p>Be aware that your code shouldn’t occupy to much time on the CPU. Otherwise one such block of code may increase the response time for several requests which are ready to be sent back, but waiting.</p>\n<h3 id=\"all-kinds-of-pools\" style=\"position:relative;\"><a href=\"#all-kinds-of-pools\" aria-label=\"all kinds of pools permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>All kinds of pools</h3>\n<p>As an extreme case we may assign a dedicated thread pool for each entity like RPC client, HTTP client or database connection pool. Pros would be separation of concerns, absence of single point of failure. Cons are too many threads to use, which may cause some fighting for resources. But still, if you know the distribution of traffic and know that it’s unlikely for different resources to be used at the same time, it could be a viable solution as well.</p>\n<p>In my real application I have this separation:</p>\n<ul>\n<li>Thread pool for a <a href=\"https://netty.io/\">netty</a> HTTP server and all netty-based HTTP clients.</li>\n<li>Thread pool for application code in which most of the business logic is happening along with parsing and serialization of JSON/protobuf/whatever.</li>\n<li>Thread pool for blocking JDBC queries.</li>\n<li>Single-threaded ScheduledExecutorService for timers and periodic cache updates.</li>\n</ul>\n<p>The proportion between netty pool and application pool is totally based on a planned load on a service. Even a single-threaded pool in netty may handle a lot of traffic.</p>\n<h2 id=\"qos\" style=\"position:relative;\"><a href=\"#qos\" aria-label=\"qos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>QoS</h2>\n<p>Another thing to consider is different requirements for different resources. For example, you may have an RPC client with 2 methods. One you call on a user request, another you call in background, for example, to update some in memory cache. And if a background method can transfer more data, parses bigger objects, you may consider to move it to a separate thread pool to not harm online user requests to be suddenly slower.</p>\n<p>Same applies to more important resources vs less important resources. There might be a consideration that more resources should be allocated for the most important transaction. Sometimes even on per user basis to provide different SLA.</p>\n<h2 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>I want to leave you with few points, just to recap:</p>\n<ul>\n<li>Try to minimize a number of threads. Your application’s resilience depends on it.</li>\n<li>Don’t use Await. Never. If you have a <code class=\"language-text\">Future</code> just propagate it further.</li>\n<li>Isolate blocking code as much as possible. Use an async alternative if possible.</li>\n<li>Use direct <code class=\"language-text\">ExecutionContext</code> in your application code.</li>\n</ul>\n<p>All code is available on <a href=\"https://github.com/dkomanov/stuff/tree/master/src/com/komanov/future\">GitHub</a>. Originally posted on <a href=\"https://medium.com/@dkomanov/writing-async-app-in-scala-part-3-threading-model-ef9e9033bd33\">Medium</a>. <a href=\"https://pixabay.com/photos/craftsman-loom-craftsmanship-hands-1839920/\">Image</a> by <a href=\"https://pixabay.com/users/Pexels-2286921/?utm_source=link-attribution&#x26;utm_medium=referral&#x26;utm_campaign=image&#x26;utm_content=1839920\">Pexels</a> from <a href=\"https://pixabay.com/?utm_source=link-attribution&#x26;utm_medium=referral&#x26;utm_campaign=image&#x26;utm_content=1839920\">Pixabay</a>.</p>","fields":{"slug":"/p/writing-async-app-in-scala-part-3-threading-model/"},"frontmatter":{"rawDate":"2020-05-25T00:00:00.000Z","date":"May 25, 2020","title":"Writing Async App in Scala. Part 3: Threading Model","description":"How many threads to use? How many thread pools or execution contexts do we need? How to minimize overhead for the better performance in async world?","tags":["scala","async","threading"],"canonicalUrl":"https://medium.com/@dkomanov/writing-async-app-in-scala-part-3-threading-model-ef9e9033bd33","cover":{"publicURL":"/static/fadb849973e8ba59b3f5a9e787aafe1f/cover.jpg"}}}},"pageContext":{"slug":"/p/writing-async-app-in-scala-part-3-threading-model/","previous":{"fields":{"slug":"/p/writing-async-app-in-scala-part-2-exception-handling/"}},"next":null}}}