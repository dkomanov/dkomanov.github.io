{"componentChunkName":"component---src-templates-blog-post-js","path":"/p/replacing-hash-set-with-sorted-array-in-java/","result":{"data":{"markdownRemark":{"id":"7a9ce76d-759b-57f2-8320-96479307607e","excerpt":"This post is not about a Magical Solution that I found or some performances issues in JDK or in Scala. Here I want to describe my findings around a particular…","html":"<p>This post is not about a <a href=\"https://en.wikipedia.org/wiki/No_Silver_Bullet\">Magical Solution</a> that I found or some performances issues in <a href=\"/p/benchmarking-string-regionmatches/\">JDK</a> or in <a href=\"/p/map-performance-java-vs-scala/\">Scala</a>. Here I want to describe my findings around a particular aspect of an application that I write. I hope you’ll find something useful in this post, but don’t expect any recipes.</p>\n<p>A simplified use case in an application: on startup an application downloads a cache and then periodically updates it. The simplest example of a cache is a Set of <a href=\"https://cr.openjdk.java.net/~iris/se/17/latestSpec/api/java.base/java/util/UUID.html\">UUIDs</a>. First, I thought about optimizing it via using different implementations of Set, you may check out my <a href=\"/p/map-performance-java-vs-scala\">post</a> about it (spoiler alert: <code class=\"language-text\">java.util.HashSet</code> is very good comparing to <code class=\"language-text\">scala.collection.immutable.Set</code>).</p>\n<p>What to optimize next?</p>\n<h2 id=\"memory\" style=\"position:relative;\"><a href=\"#memory\" aria-label=\"memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory</h2>\n<p>The memory layout for <code class=\"language-text\">UUID</code> is simple: an object itself + 16 bytes (2 <code class=\"language-text\">long</code> fields). Object size on 64-bit architecture is 16 bytes: 12 bytes header + 4 bytes for alignment (according to <a href=\"https://openjdk.org/projects/code-tools/jol/\">jol</a>). So, every <code class=\"language-text\">UUID</code> object occupies 32 bytes in heap.</p>\n<p>The layout for <code class=\"language-text\">HashSet</code> is more complicated, but in essence it’s a wrapper for an array of <code class=\"language-text\">Node</code> class which has a reference to a key object. Roughly, it’s something like x4 of the payload. If you have a million of such <code class=\"language-text\">UUIDs</code> it could be a concern. Or maybe not - who cares, we are in JVM, right? :)</p>\n<p>Until <a href=\"https://openjdk.org/projects/valhalla/\">Project Valhalla</a> is not done, especially <a href=\"https://openjdk.org/jeps/401\">JEP-401</a> part of it, if we want to make memory more manageable, we need to do tricks.</p>\n<p>The only trick in JVM is to use arrays, as an array is always contiguous in memory. Meaning, that if we will create an array of <code class=\"language-text\">long</code> of 2x size, then we will get enough memory to store an array of <code class=\"language-text\">UUID</code>. How does it help us? Well, instead of using <code class=\"language-text\">HashSet</code> we could sort an array of <code class=\"language-text\">UUID</code> and then use <a href=\"https://cr.openjdk.java.net/~iris/se/17/latestSpec/api/java.base/java/util/Arrays.html#binarySearch(T%5B%5D,T,java.util.Comparator)\">binary search</a> to determine if an array contains a <code class=\"language-text\">UUID</code>.</p>\n<p>Simply put:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">UUID<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UUID</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> found <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">binarySearch</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> found <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> found <span class=\"token operator\">&lt;</span> array<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Of course, <code class=\"language-text\">UUID[]</code> doesn’t do much for us, a it still has 2x overhead of <code class=\"language-text\">UUID</code> object.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> array<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bits <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">[</span>size <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\narray<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>uuid <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n  bits<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> uuid<span class=\"token punctuation\">.</span><span class=\"token function\">getMostSignificantBits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  bits<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> uuid<span class=\"token punctuation\">.</span><span class=\"token function\">getLeastSignificantBits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Here we need to borrow implementation from Arrays.binarySearch class.</span>\n<span class=\"token keyword\">public</span> <span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UUID</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> low <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> high <span class=\"token operator\">=</span> size <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>low <span class=\"token operator\">&lt;=</span> high<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>low <span class=\"token operator\">+</span> high<span class=\"token punctuation\">)</span> <span class=\"token operator\">>>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">int</span> current <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> mid<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">long</span> mostBits <span class=\"token operator\">=</span> bits<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mostBits <span class=\"token operator\">&lt;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">getMostSignificantBits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          low <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mostBits <span class=\"token operator\">></span> key<span class=\"token punctuation\">.</span><span class=\"token function\">getMostSignificantBits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          high <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">long</span> leastBits <span class=\"token operator\">=</span> bits<span class=\"token punctuation\">[</span>current <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leastBits <span class=\"token operator\">&lt;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">getLeastSignificantBits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n              low <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leastBits <span class=\"token operator\">></span> key<span class=\"token punctuation\">.</span><span class=\"token function\">getLeastSignificantBits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n              high <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">else</span>\n              <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In this solution we use almost exactly bytes in heap as we need (with only small array overhead).</p>\n<h2 id=\"going-off-heap\" style=\"position:relative;\"><a href=\"#going-off-heap\" aria-label=\"going off heap permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Going Off-Heap</h2>\n<p>Why <a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/jdk/internal/misc/Unsafe.java#L621\">off-heap</a>? To say the truth - just for fun. I wouldn’t put anything of this sort in production without an <a href=\"https://blogs.oracle.com/javamagazine/post/the-unsafe-class-unsafe-at-any-speed\">actual</a> necessity. However, why not to investigate this possibility as well from the performance perspective?</p>\n<p>To fetch the cache I use an HTTP client based on <a href=\"https://netty.io/\">netty</a>. In netty you may use <a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/jdk/internal/misc/Unsafe.java#L621\">off-heap</a> memory for internal buffers etc. Which means that we can even obtain a cache with zero-copy!</p>\n<p>Basically, instead of having <code class=\"language-text\">long[]</code> we need to allocate memory directly via Unsafe or via netty’s API: <a href=\"https://netty.io/4.1/api/io/netty/buffer/ByteBuf.html\">ByteBuf</a> and <a href=\"https://netty.io/4.1/api/io/netty/buffer/PooledByteBufAllocator.html\">Allocator</a>. All the code you may find <a href=\"https://github.com/dkomanov/stuff/tree/16685505efad45555f0f048601c049b028835fe0/src/com/komanov/offheap\">here</a>.</p>\n<p>What is zero-copy for netty? Basically, from netty you get response body in a series of <code class=\"language-text\">ByteBuf</code> instances that contain references to off-heap allocated memory with the chunk of the data. What you can do is to create a <code class=\"language-text\">CompositeByteBuf</code> and add all chunks to this composite buffer (if cache-server responds with already sorted, prepared data), then you don’t need to copy those chunks and just reuse it.</p>\n<h2 id=\"benchmarks\" style=\"position:relative;\"><a href=\"#benchmarks\" aria-label=\"benchmarks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Benchmarks!</h2>\n<p>And now it’s time to benchmark all the proposed solutions and to find out, what’s best in terms of performance!</p>\n<p>Disclaimer: <a href=\"http://wiki.jvmlangsummit.com/images/1/1d/PerformanceAnxiety2010.pdf\">beware</a> of the micro-benchmark results.</p>\n<p>At the end I decided to include benchmarks for <code class=\"language-text\">java.util.Set</code> and <code class=\"language-text\">scala.collection.immutable.Set</code> as a reference and a kind of baseline. Then we have 2 implementations based on Java Array: array of <code class=\"language-text\">UUID</code> (just for the reference) and array of <code class=\"language-text\">long</code> (as a memory optimization). And then we have benchmarks for off-heap array implementation based on <code class=\"language-text\">Unsafe</code> class, <code class=\"language-text\">ByteBuf</code> implementation from netty v4 (<code class=\"language-text\">4.1.79.Final</code>) and <code class=\"language-text\">Buffer</code> implementation from netty v5 alpha version (<code class=\"language-text\">5.0.0.Alpha4</code>).</p>\n<h3 id=\"lookup-performance-in-3-jdks\" style=\"position:relative;\"><a href=\"#lookup-performance-in-3-jdks\" aria-label=\"lookup performance in 3 jdks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lookup performance in 3 JDKs</h3>\n<p>Here is a successful lookup (hit, contains returns true) performance in a collection of 1 million <code class=\"language-text\">UUIDs</code>. As you may see, <code class=\"language-text\">HashSet</code> is a clear leader, but this is not a <a href=\"/p/map-performance-java-vs-scala/\">surprise</a>. Scala’s <code class=\"language-text\">Set</code> performance is very close to binary search. Performance of off-heap array is very close to on-heap implementations, <code class=\"language-text\">long[]</code> is slightly better.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5bfb33450f046ca10bb224af4b21b6b4/c95f0/chart-all-jdks.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.54054054054054%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkUlEQVQoz5WRy0sbURTGZ9Vt/xm3Yvs/uBTs1kJXQnFlQQUfiC1W0I2I1oVQGGJFXBRXagTTSFLU2CKJxvcrk+lMOo/7+JW5YySCmx64F853v/Pd75xjBUFAGIZEUYTW+r+O0hqpFUJoYiGI4xhLKUUzpNIk+XOFSskneRIHrs9M+RJUhFOv4/k+lhDCkGSLcKvoE9xg6hHL37sMlU4SK9zW7gmCMHUopTSE75d3nNZqj8VN/KfjUcyugwhRppNUsFD3GP1VTchc3d7hui6WkBLx4KA/mye3NJ22LyXyAf9SuWBxahBCz3CbnnM3DsOlKqDxGg2zC0tJiPaXWLD76Bpc4/DbTCqYXL83sDOdvJlYZ3Vu0gjGCe677OQH6P4wy8TuRcpPx4rlOpqzoQ7ej7TxusemlPlsHv4Cfz718nHsJe3vbDLTI9BwiBLc/sry6AtevR1nePvM8GOZzt2qXivOt9f4UVxmdatMrbJnWnACuNrJsVdcYCVbpnJQMDNMPqrsHnFcmGdls0jh2m9ZmOYf9WJORqembjUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Successful Lookup on a set of 1M items, all JDKs\"\n        title=\"Successful Lookup on a set of 1M items, all JDKs\"\n        src=\"/static/5bfb33450f046ca10bb224af4b21b6b4/50383/chart-all-jdks.png\"\n        srcset=\"/static/5bfb33450f046ca10bb224af4b21b6b4/1d79a/chart-all-jdks.png 185w,\n/static/5bfb33450f046ca10bb224af4b21b6b4/1efb2/chart-all-jdks.png 370w,\n/static/5bfb33450f046ca10bb224af4b21b6b4/50383/chart-all-jdks.png 740w,\n/static/5bfb33450f046ca10bb224af4b21b6b4/73caa/chart-all-jdks.png 1110w,\n/static/5bfb33450f046ca10bb224af4b21b6b4/536c7/chart-all-jdks.png 1480w,\n/static/5bfb33450f046ca10bb224af4b21b6b4/c95f0/chart-all-jdks.png 1842w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"lookup-performance-for-different-set-size\" style=\"position:relative;\"><a href=\"#lookup-performance-for-different-set-size\" aria-label=\"lookup performance for different set size permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lookup performance for different Set size</h3>\n<p>Also, nothing unexpected here. Performance of <code class=\"language-text\">HashSet</code> doesn’t depend on the collection size, performance of all other implementations degrades <a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">logarithmically</a>.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6a59147e656ef3cc5dad410a30bfaa44/2aa89/chart-all-sizes.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.513513513513516%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/0lEQVQoz5WQ607DMAyF+/5PCWiwS9natc7VTj6UdCsg8QdLn2JZztHxGWKMqCq1Vkop/6dWTJXT6cThcGBIKWFmfwq2WefR8wNrPOaWE2+vL5tgc9fYRfrS9mrH0FpIavikndBen8jZ+q5qYRw/u8uhufs+uZKtELQQsxFi+6i4NeDFE8R1/CL46U4OngqbiYehIefcBVut88TtfMFfbyzjiLuOuPEDd3nHfR7xtzNyPeKmM0EmiuY9lmftJzenbllYpzsyL6z3lXleEXG4mHA+IRIJIW/Oo+FD3ONq1YSHZ9OGMSZKpWOlEmLsOXkfyFkR5zArPRpVQ0R+OWyCX7iLJCKl1VrRAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Successful Lookup, all sizes, openjdk-17\"\n        title=\"Successful Lookup, all sizes, openjdk-17\"\n        src=\"/static/6a59147e656ef3cc5dad410a30bfaa44/50383/chart-all-sizes.png\"\n        srcset=\"/static/6a59147e656ef3cc5dad410a30bfaa44/1d79a/chart-all-sizes.png 185w,\n/static/6a59147e656ef3cc5dad410a30bfaa44/1efb2/chart-all-sizes.png 370w,\n/static/6a59147e656ef3cc5dad410a30bfaa44/50383/chart-all-sizes.png 740w,\n/static/6a59147e656ef3cc5dad410a30bfaa44/73caa/chart-all-sizes.png 1110w,\n/static/6a59147e656ef3cc5dad410a30bfaa44/536c7/chart-all-sizes.png 1480w,\n/static/6a59147e656ef3cc5dad410a30bfaa44/2aa89/chart-all-sizes.png 1698w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"off-heap-performance\" style=\"position:relative;\"><a href=\"#off-heap-performance\" aria-label=\"off heap performance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Off-Heap Performance</h3>\n<p>I excluded benchmarks of <code class=\"language-text\">CompositeByteBuf</code> and <code class=\"language-text\">CompositeBuffer</code>, because, as you may see, its performance is awful. Actually, it’s not a surprise if you think about it. The way I composed it in test is splitting all data in chunks of 4000 bytes and adding it to a composite buffer to simulate packets in the real network. For each lookup by index <code class=\"language-text\">CompositeByteBuf</code> should iterate over all buffers to find the relevant chunk… So, zero-copy has its huge cost :)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e242594f3d86321e54000f0e24eda242/c95f0/chart-off-heap.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.54054054054054%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABaklEQVQoz2WSyUsDMRSH55/24EEP7uKKBT3oSfQiLoigBz0oKi4VFBSqUi1uiGs7znQmk0nySTKdavXBIwu/fPm9vHhxHCOEaKbWGmNMM5VWKK3h116eYJBSkyTSnbPh5ZM8cnGqlVvPXW+zUN5zc7vXCgQZh/i1KmEYOkOeUgotJeaPM5lKiCTjZ6tMXWy0AhtaG5Go8/7xjl/zG0DgdXIM8fSAK0IpNwq/SjI6ROFkienLzcyNSjF5JRaKIZWKqB6RyMSV7dmCn3s7SO/vnFCrrFRRqyIG+5goLjJdyoAWp4IvxG05u9wY/oYDvg338HpzyVMa2Hd24sQ6HB6kcLLMzNWWE9ur4tIFL2MDDZfqX6O8xEDQ18XKzhxtx/MNJ1D//ER0dzJyOEvhbL0JDM7Pee5vdx3W+qc5+ehF0hAWi5Qru+xVShAZ7Ot8BQnR0S6nd/ucViogM6D/4uMfrJFGj/YnYYxuAX4DIVxdlVHDQtsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Successful Lookup on a set of 1M items, off-heap only\"\n        title=\"Successful Lookup on a set of 1M items, off-heap only\"\n        src=\"/static/e242594f3d86321e54000f0e24eda242/50383/chart-off-heap.png\"\n        srcset=\"/static/e242594f3d86321e54000f0e24eda242/1d79a/chart-off-heap.png 185w,\n/static/e242594f3d86321e54000f0e24eda242/1efb2/chart-off-heap.png 370w,\n/static/e242594f3d86321e54000f0e24eda242/50383/chart-off-heap.png 740w,\n/static/e242594f3d86321e54000f0e24eda242/73caa/chart-off-heap.png 1110w,\n/static/e242594f3d86321e54000f0e24eda242/536c7/chart-off-heap.png 1480w,\n/static/e242594f3d86321e54000f0e24eda242/c95f0/chart-off-heap.png 1842w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>It was a fun exercise for me. There is always a trade-off between memory and CPU usage, and this benchmark shows it well. I guess it’s possible to build something fine-tuned tailored to <code class=\"language-text\">UUID</code>, but I’d prefer to wait for the <a href=\"https://openjdk.org/projects/valhalla/\">Valhalla</a> :)</p>\n<p>The overhead of <code class=\"language-text\">ByteBuf</code> comparing to direct use of <code class=\"language-text\">Unsafe</code> is surprising. Though, it improved since jdk8, but still it’s like one third slower. Custom binary search over array of <code class=\"language-text\">long</code> does slightly better, which is actually very cool to see.</p>\n<p>I’d say if memory is not an important concern for you, there is no need to replace <code class=\"language-text\">HashSet</code> with <code class=\"language-text\">long[]</code>. 4x in memory usage compensate well with 6x performance. And with Valhalla Project memory usage eventually will go down as well. At least one might hope.</p>\n<p>Play with charts <a href=\"/charts/offheap-array\">here</a>. Source code is on <a href=\"https://github.com/dkomanov/stuff/blob/16685505efad45555f0f048601c049b028835fe0/src/com/komanov/offheap/jmh/Benchmarks.scala\">GitHub</a>. Originally posted on <a href=\"https://dkomanov.medium.com/replacing-hashset-with-sorted-array-and-binary-search-in-java-4a3b8023f0b\">Medium</a>. <a href=\"https://pixabay.com/illustrations/binary-zero-one-digital-blue-797274/\">Cover image</a> by <a href=\"https://pixabay.com/users/geralt-9301/\">geralt</a> from <a href=\"https://pixabay.com/\">Pixabay</a>.</p>","fields":{"slug":"/p/replacing-hash-set-with-sorted-array-in-java/"},"frontmatter":{"rawDate":"2022-08-14T00:00:00.000Z","date":"August 14, 2022","title":"Replacing HashSet with Sorted Array and Binary Search in Java?","description":"An attempt to replace HashSet with sorted array and binary search for memory optimization. Including off-heap storage.","tags":["java","hashset","benchmark","performance","memory","offheap"],"canonicalUrl":"https://dkomanov.medium.com/replacing-hashset-with-sorted-array-and-binary-search-in-java-4a3b8023f0b","cover":{"publicURL":"/static/00809f1e5318c55b2be663f181375daf/cover.jpg"}}}},"pageContext":{"slug":"/p/replacing-hash-set-with-sorted-array-in-java/","previous":{"fields":{"slug":"/p/map-performance-java-vs-scala/"}},"next":{"fields":{"slug":"/p/ultimate-off-heap-hash-set-using-redis/"}}}},"staticQueryHashes":["3675711862"]}