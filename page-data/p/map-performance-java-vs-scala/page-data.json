{"componentChunkName":"component---src-templates-blog-post-js","path":"/p/map-performance-java-vs-scala/","result":{"data":{"markdownRemark":{"id":"06ffa71a-d468-56a1-84ce-1371798ca775","excerpt":"Yet another post about performance and microbenchmarks. Beware of the results. I was wondering about performance of Scala collections and especially with…","html":"<p>Yet another post about performance and microbenchmarks. <a href=\"http://wiki.jvmlangsummit.com/images/1/1d/PerformanceAnxiety2010.pdf\">Beware</a> of the results.</p>\n<p>I was wondering about performance of <a href=\"https://docs.scala-lang.org/overviews/collections/overview.html\">Scala</a> <a href=\"https://docs.scala-lang.org/overviews/collections-2.13/overview.html\">collections</a> and especially with comparison to its Java counterparts. And few days ago, working on my day-to-day work stuff I decided to indulge myself and benchmark it (finally!). I worked on some simple but quite big cache (up to 1 million keys), so I had to decide, which collection to use :) BTW, there aren’t a lot of good benchmarks done in this area (<a href=\"https://www.lihaoyi.com/post/BenchmarkingScalaCollections.html\">this one</a> is big and good, but old and doesn’t make comparisons with Java). Anyway, let’s go straight to benchmarks!</p>\n<h2 id=\"benchmark-case\" style=\"position:relative;\"><a href=\"#benchmark-case\" aria-label=\"benchmark case permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Benchmark Case</h2>\n<p>I want to benchmark 2 cases: <code class=\"language-text\">Map[UUID, V]</code> and <code class=\"language-text\">Set[UUID]</code>, as I was going to need them both. <a href=\"https://cr.openjdk.java.net/~iris/se/17/latestSpec/api/java.base/java/util/UUID.html\">UUID</a> is used as key, which is slightly less boring than String or Int :) (it’s slightly faster than String’s equals/hashCode and slightly more complicated than Int). Because it’s a cache, I’m less concerned about how much time it takes to build a Map, and more about how much it takes to perform a lookup.</p>\n<p>What am I going to benchmark? For <code class=\"language-text\">Map[UUID, V]</code>: <a href=\"https://cr.openjdk.java.net/~iris/se/17/latestSpec//api/java.base/java/util/HashMap.html\">java.util.HashMap</a>, <a href=\"https://github.com/scala/scala/blob/2.12.x/src/library/scala/collection/convert/Wrappers.scala#L317\">Wrapper</a> for java.util.Map, <a href=\"https://github.com/scala/scala/blob/2.12.x/src/library/scala/collection/immutable/Map.scala\">immutable.Map</a> and <a href=\"https://github.com/scala/scala/blob/2.12.x/src/library/scala/collection/mutable/Map.scala\">mutable.Map</a>. And the same for Set.</p>\n<p>A single benchmark consists of 10 lookups, so when you see 100 nanoseconds, it’s on average 10 nanoseconds per lookup.</p>\n<h2 id=\"benchmarks\" style=\"position:relative;\"><a href=\"#benchmarks\" aria-label=\"benchmarks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Benchmarks</h2>\n<p>So, I wrote all the benchmarks, ran and…</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5ae2b875eec7c85329b075c81afb3415/c95f0/chart-scala-2-12-jdks.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.54054054054054%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABuElEQVQoz02QzUtUURjG76Jl4KJNixatXbVwU5sWtWqn7oJaCSXkIgR3Ev0JgoupxQRFWCRBH6DkSKjRzIQxWI7o5KSpjYXM6VrNPXfO1y/uORemAy+853nP+b0PT5RISZpKUgUGwFmcc3mBcwZn9X9aVhZH7yhtUUqjtSayVnvRHtcwouIfOptDAP3jJemnG0H3ywLMyhZqZxqcQSUd4l+COD4mMkp6YLp+G1m7TjCpPNBv/1YkqVzuAbNlgGl/4G/pDMYkpKqLEG2STkKklMQC3foEydqI7zOgNcoDzdEsneoVdA60uXPb3SJdGQgGsru1vo9wwaHcnoTPNwNEp8F1s8VRYQhbGwyxWBNct38j7o3zff4sc7tlTB5olm/UELD6agNVPM/H6iCrIob8Y7ywROvqKerLF5jfX8+IAbizy+FwP5VnJxmYHUMa3QNOlWH00jTcihib6ePa20d+uLQHk+Ml5MhpCo9PcPHFXa8f/IE7Uw0OhvupzkScezqKNKYHrP+E8sIWvL9PZfshy62mH35tQ2lxH7n4gM0vRd7srfm0RMfxekUQzz3hsFHgefMdJneeAf8BT3xBIh8WoIUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Map Lookup for different JVMs, Scala 2.12\"\n        title=\"Map Lookup for different JVMs, Scala 2.12\"\n        src=\"/static/5ae2b875eec7c85329b075c81afb3415/50383/chart-scala-2-12-jdks.png\"\n        srcset=\"/static/5ae2b875eec7c85329b075c81afb3415/1d79a/chart-scala-2-12-jdks.png 185w,\n/static/5ae2b875eec7c85329b075c81afb3415/1efb2/chart-scala-2-12-jdks.png 370w,\n/static/5ae2b875eec7c85329b075c81afb3415/50383/chart-scala-2-12-jdks.png 740w,\n/static/5ae2b875eec7c85329b075c81afb3415/73caa/chart-scala-2-12-jdks.png 1110w,\n/static/5ae2b875eec7c85329b075c81afb3415/536c7/chart-scala-2-12-jdks.png 1480w,\n/static/5ae2b875eec7c85329b075c81afb3415/c95f0/chart-scala-2-12-jdks.png 1842w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>I was disappointed to say the least: Scala collections were significantly slower… Wow.</p>\n<p>Then I remembered, that I still used Scala 2.12 in my benchmarking project, I was postponing the upgrade to <a href=\"https://github.com/scala/scala/releases/v2.13.0\">2.13</a> for some time and I guess the time has come. <a href=\"https://github.com/dkomanov/stuff/commit/21fd664d8506feef443a8c66e84ccec23ffeb3ac\">Migration</a> wasn’t painful as there isn’t a lot of code. Running again and…</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/343ef09c7d90d308767a5e71443b39b8/c95f0/chart-scala-2-13-jdks.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.54054054054054%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpklEQVQoz22RvWsUQRjGt9R/wl6QNGms00is0oikDalMEyFYiCAI/gt+gIXJoaKQQkSiiXpRE/AUTQ7JZRMVgxsV4uVuE52d2fn6ycxePgQH3uXZZ979zfPOJkUhUKVB/t7CyDZhee+rCtoIXNnG+0N+LOJ+eGrj0NpgjCExWka7TC+hPp6LTc5qnNNR6827yHdDle8cPpQPPRIrvhKO1cUf8m6XPN8hsUZFoGpNIJdHqjMDzJmodTaJbJyq0voAtFHbfBnxuh9cidKKTmebQhQHCdXKBVRz9B9gTJjVkI3T/wEuIeZPxKR76UP0pFRFNMr1i4ilEWwPaK2OOgBFYxDTAzpnora7TcTLPqwpoHeXYSWgCV/uLoxCOl6NWVapWU35cfkkNM/EV2ura2Cnw88rw8h63z5o72cl9Qxq4zXUWMLs4gCPs43YtNKF21dn2Tp7lPdzx7n/+W0YjLaCO/fW2Rg8Rmv6COcXrqHDuD1o8mETnj9qweINXqS3ePKtFTc//fLMzGWo+iTNtZtMf3kT/W3hefiqQ/70Ad/XrjOVPsMcAv4FLGJL+ZYd1OAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Map Lookup for different JVMs, Scala 2.13\"\n        title=\"Map Lookup for different JVMs, Scala 2.13\"\n        src=\"/static/343ef09c7d90d308767a5e71443b39b8/50383/chart-scala-2-13-jdks.png\"\n        srcset=\"/static/343ef09c7d90d308767a5e71443b39b8/1d79a/chart-scala-2-13-jdks.png 185w,\n/static/343ef09c7d90d308767a5e71443b39b8/1efb2/chart-scala-2-13-jdks.png 370w,\n/static/343ef09c7d90d308767a5e71443b39b8/50383/chart-scala-2-13-jdks.png 740w,\n/static/343ef09c7d90d308767a5e71443b39b8/73caa/chart-scala-2-13-jdks.png 1110w,\n/static/343ef09c7d90d308767a5e71443b39b8/536c7/chart-scala-2-13-jdks.png 1480w,\n/static/343ef09c7d90d308767a5e71443b39b8/c95f0/chart-scala-2-13-jdks.png 1842w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Now it’s interesting… I would even say unexpected.</p>\n<p>Performance of <code class=\"language-text\">mutable.Map</code> is now more or less the same as <code class=\"language-text\">java.util.HashMap</code> (depending on the size of Map, for smaller maps it’s even faster!). But performance of <code class=\"language-text\">immutable.Map</code> is even worse. Wow again.</p>\n<p>Let’s compare now between different Scala versions for openjdk-17:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f557b82003be7e9a362e93a903788c99/c95f0/chart-scala-vs-scala.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.54054054054054%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABmklEQVQoz3WRTWtUMRSG8x8Ef4I7wX8g6LK4UMSV6MIuBMGVv8CNFNxJQaQtYl2IVmvVGQtWW3Ej1IW2gpZCO9MWOi7qnc97k5OcPDK54/UDDYQknDfPefPG5HmOtRZrHbYoEJcToxJj/M9UIuVIa1TER0Q83nuMqv5ernb/hGpItZCtYj9eJHTWkl7yLu0so93uYIbU8jKEfgO3eYPQWUdT8/AXUBJQdu/RfWiQ/fkELFyP79kB+SDHiAhRfSr4g6VS2LidzhrkD6CqlLr9R/QWDNKqpQaqHh06inHoMOCDx3cdbms+CW1zhpAc/gIGjXgvDHu7xiy9pwb/rTbKyFdxGdLjAntXLrM9fpS4aLi+MMbJ+k2s5EkUws+cC5rjl9i7dozBoiG26iUv+qqxeb/pmHjW58PYGbbPHoYXhnPTRzB3zjNw/dFfBVa+BiYeZ3w6foKdC4dwdcPVuVOcfnWriiIB13Y8U8sFu7Uluq/vo41JVjbmuLvxDgkycqesbnlm3gxoPX9J7+0soTnJk88PmPqyjEatgD8AEQRGC8BtDPAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Map Lookup for different Scala versions, openjdk-17\"\n        title=\"Map Lookup for different Scala versions, openjdk-17\"\n        src=\"/static/f557b82003be7e9a362e93a903788c99/50383/chart-scala-vs-scala.png\"\n        srcset=\"/static/f557b82003be7e9a362e93a903788c99/1d79a/chart-scala-vs-scala.png 185w,\n/static/f557b82003be7e9a362e93a903788c99/1efb2/chart-scala-vs-scala.png 370w,\n/static/f557b82003be7e9a362e93a903788c99/50383/chart-scala-vs-scala.png 740w,\n/static/f557b82003be7e9a362e93a903788c99/73caa/chart-scala-vs-scala.png 1110w,\n/static/f557b82003be7e9a362e93a903788c99/536c7/chart-scala-vs-scala.png 1480w,\n/static/f557b82003be7e9a362e93a903788c99/c95f0/chart-scala-vs-scala.png 1842w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Yes, we clearly see that mutable implementation is improved significantly and immutable implementation degraded.</p>\n<h2 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>From these benchmarks we can see that performance of JDK implementation of HashMap (HashSet’s implementation just <a href=\"https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/HashSet.java#L107\">uses HashMap</a> internally) was degraded a little bit since openjdk-8 (strange).</p>\n<p>Wrapped version performance improved from jdk-8 to jdk-17, maybe JVM optimizes more aggressively in the latest versions.</p>\n<p>I don’t know why, but performance of immutable version of Map/Set in Scala degraded, which is a bit counter-intuitive, as immutable collection can be optimized better than mutable… But this is how it’s now. If you really need performance for your lookups - use mutable versions (either Java or Scala)…</p>\n<p>P.S. My initial benchmarks had some unpredictable spikes (10x) for Scala collections from time to time (like 500 nanos for 100K elements and then 5000 nanos for 10K elements, which doesn’t make much sense). Those spikes were “consistent” in a way, than on each run (which takes ~45 minutes) there were few spikes for different JDK, different sizes, different Scala collections. I decided to remove possibility of strange behavior of Scala collections by <a href=\"https://github.com/dkomanov/stuff/commit/acae4c45f439c454d2a3bd247928a56747dd7813\">replacing it</a> with vanilla Java code which actually helped (sic!) Don’t know what to make of it, except for “I trust Java more” :)</p>\n<p>Play with charts <a href=\"/charts/set-map-java-vs-scala\">here</a>. Source code is on <a href=\"https://github.com/dkomanov/stuff/blob/4be6934c27626678028fa9aa3c5ab508ac694780/src/com/komanov/collection/jmh/SetMapJavaVsScalaBenchmarks.scala\">GitHub</a>. Originally posted on <a href=\"https://dkomanov.medium.com/map-performance-java-vs-scala-72fec18db020\">Medium</a>. <a href=\"https://pixabay.com/photos/dictionary-words-abc-letters-390027/\">Cover image</a> by <a href=\"https://pixabay.com/users/pdpics-44804/\">pdpics</a> from <a href=\"https://pixabay.com/\">Pixabay</a>.</p>","fields":{"slug":"/p/map-performance-java-vs-scala/"},"frontmatter":{"rawDate":"2022-08-02T00:00:00.000Z","date":"August 02, 2022","title":"Map Performance: Java vs Scala","description":"A microbenchmark of Map.get and Set.contains performance for different JDK and Scala versions","tags":["java","scala","collection","benchmark","performance"],"canonicalUrl":"https://dkomanov.medium.com/map-performance-java-vs-scala-72fec18db020","cover":{"publicURL":"/static/ea1c26e936af663336757c7354a13e25/cover.jpg"}}}},"pageContext":{"slug":"/p/map-performance-java-vs-scala/","previous":{"fields":{"slug":"/p/benchmarking-string-regionmatches/"}},"next":null}},"staticQueryHashes":["3675711862"]}